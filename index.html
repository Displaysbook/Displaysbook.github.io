<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>五子棋 AI（贪心版）</title>
<style>
body {
  text-align:center;
  background:#f5f5dc;
  font-family:"Microsoft YaHei";
}
canvas {
  background:#deb887;
  box-shadow:0 0 10px rgba(0,0,0,.45);
  cursor:pointer;
  margin-top:12px;
}
button {
  margin-top:10px; padding:6px 12px;
}
#status { margin-top:10px; font-weight:bold; }
</style>
</head>
<body>

<h1>五子棋 AI</h1>
<button id="restart">重新开始</button>

<canvas id="board" width="640" height="640"></canvas>
<div id="status"></div>

<script>
const N=15, EMPTY=0, BLACK=1, WHITE=-1;
let board=[], turn=BLACK, gameOver=false, last=null;
let aiColor=WHITE, humanColor=BLACK;

const cvs=document.getElementById("board"), ctx=cvs.getContext("2d");
const cell=640/(N+1), off=cell;
const dx=[1,0,1,1], dy=[0,1,1,-1];

function inBoard(x,y){return x>=0 && x<N && y>=0 && y<N;}

function drawBoard(){
  ctx.fillStyle="#deb887";
  ctx.fillRect(0,0,640,640);
  ctx.strokeStyle="#333";
  for(let i=0;i<N;i++){
    const p=off+i*cell;
    ctx.beginPath(); ctx.moveTo(off,p); ctx.lineTo(off+(N-1)*cell,p); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p,off); ctx.lineTo(p,off+(N-1)*cell); ctx.stroke();
  }
  for(let i=0;i<N;i++)
    for(let j=0;j<N;j++)
      if(board[i][j]!==EMPTY) drawStone(i,j,board[i][j]);

  if(last){
    ctx.fillStyle="red";
    ctx.beginPath();
    ctx.arc(off+last.y*cell,off+last.x*cell,cell*0.12,0,Math.PI*2);
    ctx.fill();
  }
}

function drawStone(x,y,p){
  const cx=off+y*cell, cy=off+x*cell, r=cell*0.4;
  const g=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.1,cx,cy,r);
  if(p===BLACK){ g.addColorStop(0,"#fff"); g.addColorStop(1,"#000"); }
  else{ g.addColorStop(0,"#fff"); g.addColorStop(1,"#ccc"); }
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
}

function isFive(p,x,y){
  for(let d=0;d<4;d++){
    let c=1, nx=x+dx[d], ny=y+dy[d];
    while(inBoard(nx,ny)&&board[nx][ny]==p){ c++; nx+=dx[d]; ny+=dy[d]; }
    nx=x-dx[d]; ny=y-dy[d];
    while(inBoard(nx,ny)&&board[nx][ny]==p){ c++; nx-=dx[d]; ny-=dy[d]; }
    if(c>=5) return true;
  }
  return false;
}

// ---------------- 贪心评分函数 ----------------
function evalPoint(p,x,y){
  let score = 0;

  board[x][y] = p;
  if(isFive(p,x,y)){ board[x][y]=EMPTY; return 99999999; }
  board[x][y] = EMPTY;

  board[x][y] = -p;
  if(isFive(-p,x,y)){ board[x][y]=EMPTY; return 80000000; }
  board[x][y] = EMPTY;

  // 进一步评分：统计“连珠模式”
  score += getScore(p,x,y);
  score += getScore(-p,x,y) * 0.8; // 防守权重稍低
  return score;
}

function getScore(p,x,y){
  let total=0;

  for(let d=0; d<4; d++){
    let cnt=1, block=0;

    // 正方向
    let i=x+dx[d], j=y+dy[d];
    while(inBoard(i,j) && board[i][j]==p){ cnt++; i+=dx[d]; j+=dy[d]; }
    if(!inBoard(i,j) || board[i][j]==-p) block++;

    // 反方向
    i=x-dx[d]; j=y-dy[d];
    while(inBoard(i,j) && board[i][j]==p){ cnt++; i-=dx[d]; j-=dy[d]; }
    if(!inBoard(i,j) || board[i][j]==-p) block++;

    // 根据连子数 + 封堵数评分
    if(cnt>=5) total+=100000;
    else if(cnt==4 && block==0) total+=10000;     // 活四
    else if(cnt==4 && block==1) total+=3000;      // 冲四
    else if(cnt==3 && block==0) total+=800;       // 活三
    else if(cnt==3 && block==1) total+=200;       // 眠三
    else if(cnt==2 && block==0) total+=30;        // 活二
  }

  return total;
}

// ---------------- 贪心 AI：只选当前最高分点 ----------------
function aiMove(){
  let bestScore = -1e18;
  let bestMove = null;

  for(let i=0;i<N;i++){
    for(let j=0;j<N;j++){
      if(board[i][j]!==EMPTY) continue;

      let s = evalPoint(aiColor, i, j);
      if(s > bestScore){
        bestScore = s;
        bestMove = {x:i,y:j};
      }
    }
  }

  return bestMove;
}

// ---------------- 落子逻辑 ----------------
cvs.addEventListener("click", e=>{
  if(gameOver || turn!==humanColor) return;

  const rect=cvs.getBoundingClientRect();
  const j=Math.round((e.clientX-rect.left-off)/cell);
  const i=Math.round((e.clientY-rect.top-off)/cell);
  if(!inBoard(i,j) || board[i][j]!==EMPTY) return;

  board[i][j]=humanColor;
  last={x:i,y:j};
  drawBoard();

  if(isFive(humanColor,i,j)){
    document.getElementById("status").textContent="你赢了！";
    gameOver=true; return;
  }

  turn = aiColor;
  document.getElementById("status").textContent = "AI 思考中...";

  setTimeout(()=>{
    const mv=aiMove();
    if(!mv){ document.getElementById("status").textContent="平局"; gameOver=true; return; }

    board[mv.x][mv.y]=aiColor;
    last=mv;
    drawBoard();

    if(isFive(aiColor,mv.x,mv.y)){
      document.getElementById("status").textContent="AI 获胜";
      gameOver=true; return;
    }

    turn=humanColor;
    document.getElementById("status").textContent="轮到你了";
  },50);
});

// ---------------- 初始化 ----------------
function init(){
  board = Array.from({length:N},()=>Array(N).fill(0));
  gameOver=false;
  turn=humanColor=BLACK;
  aiColor=WHITE;
  last=null;
  document.getElementById("status").textContent="玩家先手（黑）";
  drawBoard();
}

document.getElementById("restart").onclick=()=>init();
init();
</script>

</body>
</html>
