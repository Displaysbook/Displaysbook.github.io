<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>五子棋 AI</title>
<style>
body {
  text-align:center;
  background:#f5f5dc;
  font-family:"Microsoft YaHei";
}
.topbar { margin-top:10px; display:flex; gap:12px; justify-content:center; align-items:center; }
canvas {
  background:#deb887;
  box-shadow:0 0 10px rgba(0,0,0,.5);
  cursor:pointer;
  margin-top:12px;
}
button {
  margin-top:10px;
  padding:6px 12px;
  font-size:15px;
  cursor:pointer;
}
#status { margin-top:10px; font-weight:bold; }
label { font-size:14px; cursor:pointer; }
</style>
</head>
<body>
<h1>五子棋 AI </h1>

<div class="topbar">
  <label><input type="radio" name="starter" value="human" checked> 玩家先手（黑）</label>
  <label><input type="radio" name="starter" value="ai"> AI 先手（白）</label>
  <button id="restart">重新开始</button>
</div>

<canvas id="board" width="640" height="640"></canvas>
<div id="status"></div>

<script>
const N=15,EMPTY=0,BLACK=1,WHITE=-1;
let board=[],turn=BLACK,gameOver=false,last=null;
const cvs=document.getElementById("board"),ctx=cvs.getContext("2d");
const cell=640/(N+1),off=cell;
function inBoard(x,y){return x>=0&&x<N&&y>=0&&y<N;}
const dx=[1,0,1,1],dy=[0,1,1,-1];

function drawBoard(){
  ctx.fillStyle="#deb887";ctx.fillRect(0,0,640,640);
  ctx.strokeStyle="#333";
  for(let i=0;i<N;i++){
    const p=off+i*cell;
    ctx.beginPath();ctx.moveTo(off,p);ctx.lineTo(off+(N-1)*cell,p);ctx.stroke();
    ctx.beginPath();ctx.moveTo(p,off);ctx.lineTo(p,off+(N-1)*cell);ctx.stroke();
  }
  for(let i=0;i<N;i++)for(let j=0;j<N;j++){
    if(board[i][j]!==EMPTY)drawStone(i,j,board[i][j]);
  }
  if(last){
    const {x,y}=last;
    ctx.fillStyle="red";
    ctx.beginPath();ctx.arc(off+y*cell,off+x*cell,cell*0.12,0,Math.PI*2);ctx.fill();
  }
}
function drawStone(x,y,p){
  const cx=off+y*cell,cy=off+x*cell,r=cell*0.4;
  const g=ctx.createRadialGradient(cx-r*0.3,cy-r*0.3,r*0.1,cx,cy,r);
  if(p===BLACK){g.addColorStop(0,"#fff");g.addColorStop(1,"#000");}
  else{g.addColorStop(0,"#fff");g.addColorStop(1,"#ccc");}
  ctx.fillStyle=g;ctx.beginPath();ctx.arc(cx,cy,r,0,Math.PI*2);ctx.fill();
}
function isFive(p,x,y){
  for(let d=0;d<4;d++){
    let c=1,nx=x+dx[d],ny=y+dy[d];
    while(inBoard(nx,ny)&&board[nx][ny]===p){c++;nx+=dx[d];ny+=dy[d];}
    nx=x-dx[d];ny=y-dy[d];
    while(inBoard(nx,ny)&&board[nx][ny]===p){c++;nx-=dx[d];ny-=dy[d];}
    if(c>=5)return true;
  }return false;
}

function checkLine(p,x,y,stat){
  for(let d=0;d<4;d++){
    let line=[];
    for(let k=4;k>=1;k--){
      let nx=x-dx[d]*k,ny=y-dy[d]*k;
      line.push(inBoard(nx,ny)?board[nx][ny]:2);
    }
    line.push(p);
    for(let k=1;k<=4;k++){
      let nx=x+dx[d]*k,ny=y+dy[d]*k;
      line.push(inBoard(nx,ny)?board[nx][ny]:2);
    }
    for(let i=0;i+4<9;i++){
      const w=line.slice(i,i+5);
      const cnt=w.filter(v=>v===p).length;
      const em=w.filter(v=>v===0).length;
      if(cnt===4&&em===1){
        let l=i>0&&line[i-1]===0,r=i+5<9&&line[i+5]===0;
        if(l&&r)stat.open4++;else stat.closed4++;
      }
      if(cnt===3&&em===2){
        let epos=w.map((v,i)=>v===0?i:-1).filter(v=>v!=-1);
        let isopen=false;
        for(let pos of epos){
          let sim=w.slice();sim[pos]=p;
          let l=i>0&&line[i-1]===0,r=i+5<9&&line[i+5]===0;
          if(l&&r){
            if(sim[0]===p&&sim[1]===p&&sim[2]===p&&sim[3]===p)isopen=true;
            if(sim[1]===p&&sim[2]===p&&sim[3]===p&&sim[4]===p)isopen=true;
          }
        }
        if(isopen)stat.open3++;else stat.closed3++;
      }
    }
  }
}
function analyze(p,x,y){
  const s={open4:0,closed4:0,open3:0,closed3:0,five:false};
  board[x][y]=p;
  s.five=isFive(p,x,y);
  checkLine(p,x,y,s);
  board[x][y]=EMPTY;
  return s;
}
function evalMove(p,x,y){
  if(!inBoard(x,y)||board[x][y]!==EMPTY)return -1e9;
  const a=analyze(p,x,y),b=analyze(-p,x,y);
  let sc=-(Math.abs(x-7)+Math.abs(y-7));
  if(a.five)return 1e8;
  sc+=a.open4*500000+a.closed4*20000+a.open3*5000+a.closed3*500;
  if(b.five)sc+=9e7;
  sc+=b.open4*800000+b.closed4*10000+b.open3*2000;
  return sc;
}
function genMoves(){
  let has=false;
  for(let i=0;i<N;i++)for(let j=0;j<N;j++)if(board[i][j]!==EMPTY)has=true;
  if(!has)return[{x:7,y:7}];
  let used=Array.from({length:N},()=>Array(N).fill(false)),res=[];
  for(let i=0;i<N;i++)for(let j=0;j<N;j++)if(board[i][j]!==EMPTY)
    for(let a=-2;a<=2;a++)for(let b=-2;b<=2;b++){
      let x=i+a,y=j+b;
      if(inBoard(x,y)&&board[x][y]===EMPTY&&!used[x][y]){
        used[x][y]=true;res.push({x,y});
      }
    }
  return res;
}

// ---------- 两层 Minimax + αβ ----------
function minimax(depth,alpha,beta,player){
  if(depth===0)return evaluateBoard(player);
  let moves=genMoves().map(m=>({m,score:evalMove(player,m.x,m.y)}));
  moves.sort((a,b)=>b.score-a.score);
  moves=moves.slice(0,12); // 只取前12个候选
  if(player===WHITE){ // AI最大化
    let maxv=-1e9;
    for(let {m} of moves){
      board[m.x][m.y]=player;
      if(isFive(player,m.x,m.y)){board[m.x][m.y]=EMPTY;return 1e8;}
      const v=minimax(depth-1,alpha,beta,-player);
      board[m.x][m.y]=EMPTY;
      if(v>maxv)maxv=v;
      if(v>alpha)alpha=v;
      if(beta<=alpha)break;
    }
    return maxv;
  }else{ // 玩家最小化
    let minv=1e9;
    for(let {m} of moves){
      board[m.x][m.y]=player;
      if(isFive(player,m.x,m.y)){board[m.x][m.y]=EMPTY;return -1e8;}
      const v=minimax(depth-1,alpha,beta,-player);
      board[m.x][m.y]=EMPTY;
      if(v<minv)minv=v;
      if(v<beta)beta=v;
      if(beta<=alpha)break;
    }
    return minv;
  }
}
function evaluateBoard(p){
  // 粗略评估全盘
  let score=0;
  for(let i=0;i<N;i++)for(let j=0;j<N;j++)
    if(board[i][j]===EMPTY)score+=evalMove(p,i,j);
  return score;
}

function aiMove(){
  const moves=genMoves().map(m=>({m,score:evalMove(WHITE,m.x,m.y)}));
  moves.sort((a,b)=>b.score-a.score);
  let best=null,bestScore=-1e9;
  for(let {m} of moves.slice(0,12)){
    board[m.x][m.y]=WHITE;
    let val=minimax(2,-1e9,1e9,BLACK); // 2层搜索 = 自己+对手
    board[m.x][m.y]=EMPTY;
    if(val>bestScore){bestScore=val;best=m;}
  }
  return best||{x:-1,y:-1};
}

// ---------- 事件 ----------
cvs.addEventListener("click",e=>{
  if(gameOver||turn!==BLACK)return;
  const rect=cvs.getBoundingClientRect();
  const j=Math.round((e.clientX-rect.left-off)/cell);
  const i=Math.round((e.clientY-rect.top-off)/cell);
  if(!inBoard(i,j)||board[i][j]!==EMPTY)return;
  board[i][j]=BLACK;last={x:i,y:j};
  drawBoard();
  if(isFive(BLACK,i,j)){document.getElementById("status").textContent="你赢了！";gameOver=true;return;}
  turn=WHITE;
  document.getElementById("status").textContent="AI 思考中...";
  setTimeout(()=>{
    const mv=aiMove();
    if(!mv||mv.x<0){document.getElementById("status").textContent="平局";gameOver=true;return;}
    board[mv.x][mv.y]=WHITE;last={x:mv.x,y:mv.y};
    drawBoard();
    if(isFive(WHITE,mv.x,mv.y)){document.getElementById("status").textContent="AI 获胜";gameOver=true;}
    else{turn=BLACK;document.getElementById("status").textContent="轮到你了";}
  },50);
});

document.getElementById("restart").onclick=()=>init();

// 当切换先手选择时也立即重开局（满足“点击 AI 开始 AI 直接下中心”需求）
const starterRadios=document.querySelectorAll('input[name="starter"]');
starterRadios.forEach(r=>r.addEventListener('change',()=>init()));

function init(){
  board=Array.from({length:N},()=>Array(N).fill(0));
  gameOver=false;last=null;
  const starter=document.querySelector('input[name="starter"]:checked').value;
  if(starter==="ai"){
    // AI 直接下中心 (7,7)
    board[7][7]=WHITE;
    last={x:7,y:7};
    drawBoard();
    if(isFive(WHITE,7,7)){document.getElementById("status").textContent="AI 获胜";gameOver=true;turn=WHITE;return;}
    turn=BLACK;
    document.getElementById("status").textContent="轮到你了";
  }else{
    turn=BLACK;
    document.getElementById("status").textContent="玩家先手（黑子）";
    drawBoard();
  }
}
init();
</script>
</body>
</html>
