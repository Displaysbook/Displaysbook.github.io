<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>å…¨åŒå·¥å£°å­¦ Modemï¼ˆç½‘é¡µï¼šéº¦å…‹é£+æ‰¬å£°å™¨ åŒæ—¶åŒå‘é€šä¿¡ï¼‰</title>
<style>
  :root{
    --bg:#000; --fg:#00ff66; --dim:rgba(0,255,102,.25);
    --panel:rgba(0,255,102,.08); --warn:#ffd000; --err:#ff3b3b;
  }
  html,body{height:100%; margin:0; background:radial-gradient(ellipse at top,#07110a 0%,#000 55%,#000 100%); color:var(--fg);
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
  .wrap{max-width:1100px; margin:0 auto; padding:16px; display:grid; gap:12px;}
  .title{border:1px solid var(--dim); border-radius:14px; background:linear-gradient(180deg,rgba(0,255,102,.10),rgba(0,255,102,.04));
    padding:12px 14px; box-shadow:0 0 18px rgba(0,255,102,.08); display:flex; justify-content:space-between; gap:12px; align-items:baseline;}
  .title h1{margin:0; font-size:16px;}
  .hint{opacity:.8; font-size:12px; line-height:1.25}
  .grid{display:grid; grid-template-columns:1.1fr .9fr; gap:12px;}
  @media (max-width:900px){.grid{grid-template-columns:1fr;}}
  .panel{border:1px solid var(--dim); border-radius:14px; background:var(--panel); box-shadow:0 0 18px rgba(0,255,102,.06); overflow:hidden;}
  .hd{padding:10px 12px; border-bottom:1px solid var(--dim); background:rgba(0,255,102,.06); display:flex; justify-content:space-between; align-items:center;}
  .name{font-weight:700; font-size:12px; opacity:.95;}
  .badge{font-size:11px; padding:3px 8px; border:1px solid var(--dim); border-radius:999px; background:rgba(0,0,0,.25); opacity:.9;}
  .bd{padding:12px;}
  .row{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
  @media (max-width:520px){.row{grid-template-columns:1fr;}}
  .kv{border:1px solid var(--dim); border-radius:12px; padding:10px 12px; background:rgba(0,0,0,.25);}
  .k{font-size:11px; opacity:.75;}
  .v{font-size:13px; margin-top:4px;}
  button{appearance:none; border:1px solid var(--dim); background:rgba(0,255,102,.08); color:var(--fg);
    padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:700; letter-spacing:.3px; box-shadow:0 0 10px rgba(0,255,102,.06);}
  button:hover{background:rgba(0,255,102,.12);}
  button:disabled{opacity:.5; cursor:not-allowed;}
  .btn-warn{border-color:rgba(255,208,0,.35); color:var(--warn); background:rgba(255,208,0,.08);}
  .btn-err{border-color:rgba(255,59,59,.35); color:var(--err); background:rgba(255,59,59,.08);}
  label{display:inline-flex; gap:8px; align-items:center; font-size:12px; opacity:.9;
    border:1px solid var(--dim); background:rgba(0,0,0,.25); padding:8px 10px; border-radius:12px; user-select:none;}
  input[type="checkbox"]{transform:translateY(1px);}
  input[type="range"]{width:160px;}
  textarea,input[type="text"],select{
    width:100%; box-sizing:border-box; border:1px solid var(--dim); background:rgba(0,0,0,.35);
    color:var(--fg); border-radius:12px; padding:10px 12px; outline:none; font-family:inherit;
  }
  textarea{min-height:72px; resize:vertical;}
  .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .log{height:300px; overflow:auto; border:1px solid var(--dim); background:rgba(0,0,0,.35);
    border-radius:12px; padding:10px; line-height:1.35; font-size:12px; white-space:pre-wrap;}
  canvas{width:100%; height:220px; border:1px solid var(--dim); border-radius:12px; background:rgba(0,0,0,.35); display:block;}
  .muted{opacity:.7;}
  .pill{display:inline-flex; gap:8px; align-items:center;}
  .small{font-size:12px;}
</style>
</head>
<body>
<div class="wrap">
  <div class="title">
    <h1>ğŸ“ å…¨åŒå·¥å£°å­¦ Modemï¼ˆç½‘é¡µï¼šéº¦å…‹é£+æ‰¬å£°å™¨ åŒæ—¶åŒå‘é€šä¿¡ï¼‰</h1>
    <div class="hint">
      åŸç†ï¼šé¢‘åˆ†åŒå·¥ï¼ˆAâ†’B ä½é¢‘æ®µï¼›Bâ†’A é«˜é¢‘æ®µï¼‰+ æœ¬æœºé¢‘æ®µé™·æ³¢é™ä½è‡ªå›å£°ã€‚<br/>
      æœ€ç¨³ï¼šä¸¤å°è®¾å¤‡ç›¸å¯¹ã€ç¯å¢ƒå®‰é™ï¼›é¿å…çˆ†éŸ³ï¼›å¯è¯•â€œåŸå§‹éº¦å…‹é£â€ã€‚
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <div class="hd">
        <div class="name">æ§åˆ¶å°</div>
        <div class="badge" id="badge">IDLE</div>
      </div>
      <div class="bd">

        <div class="row">
          <div class="kv">
            <div class="k">è§’è‰²ï¼ˆä¸¤å°è®¾å¤‡å¿…é¡»ä¸€å°é€‰ Aï¼Œä¸€å°é€‰ Bï¼‰</div>
            <div class="v">
              <select id="role">
                <option value="A">æˆ‘æ˜¯ Aï¼ˆå‘ä½é¢‘æ®µ / æ”¶é«˜é¢‘æ®µï¼‰</option>
                <option value="B">æˆ‘æ˜¯ Bï¼ˆå‘é«˜é¢‘æ®µ / æ”¶ä½é¢‘æ®µï¼‰</option>
              </select>
            </div>
          </div>
          <div class="kv">
            <div class="k">çŠ¶æ€</div>
            <div class="v" id="status">æœªå¯åŠ¨</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">å‚æ•°</div>
          <div class="v" id="params">â€”</div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">å‘é€ï¼ˆéšæ—¶å¯å‘ï¼Œæ¥æ”¶ç«¯ä¼šåŒæ—¶è§£ç ï¼‰</div>
          <div class="v">
            <textarea id="tx" placeholder="è¾“å…¥è¦å‘é€çš„æ–‡å­—ï¼ˆå»ºè®®çŸ­ä¸€äº›æ›´ç¨³ï¼Œä¾‹å¦‚ 200 å­—å†…ï¼‰"></textarea>
            <div style="height:8px"></div>
            <div class="controls">
              <button id="btnStart">å¯åŠ¨ï¼ˆæ‰“å¼€éŸ³é¢‘+éº¦å…‹é£+æ¥æ”¶å™¨ï¼‰</button>
              <button id="btnSend" disabled>å‘é€</button>
              <button id="btnHang" class="btn-err" disabled>åœæ­¢</button>

              <label title="å‘å°„éŸ³é‡">
                å‘å°„éŸ³é‡ <input id="vol" type="range" min="0" max="100" value="55"/>
              </label>

              <label title="å°†éº¦å…‹é£æ··éŸ³åˆ°æ‰¬å£°å™¨ï¼ˆå¯èƒ½å•¸å«ï¼Œä¸å»ºè®®ï¼‰">
                <input id="monitor" type="checkbox"/>
                éº¦å…‹é£ç›‘å¬
              </label>

              <label title="å…³é—­å›å£°æ¶ˆé™¤/å™ªå£°æŠ‘åˆ¶ï¼Œé€šå¸¸æ›´åˆ©äºçº¯éŸ³è°ƒåˆ¶è§£ç ï¼Œä½†ç¯å¢ƒå™ªå£°ä¹Ÿä¼šæ›´å¤§">
                <input id="rawmic" type="checkbox"/>
                åŸå§‹éº¦å…‹é£
              </label>

              <label title="æ¨¡æ‹Ÿæ‹¨å·æ¡æ‰‹éŸ³ï¼ˆçº¯æ°›å›´ï¼‰">
                <input id="handshake" type="checkbox" checked/>
                æ‹¨å·éŸ³æ•ˆ
              </label>
            </div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">æ¥æ”¶</div>
          <div class="v">
            <input id="rx" type="text" readonly placeholder="æ”¶åˆ°çš„æ–‡æœ¬ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ"/>
            <div class="muted small" id="rxmeta" style="margin-top:6px">â€”</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">æ—¥å¿—</div>
          <div class="v"><div id="log" class="log"></div></div>
        </div>

      </div>
    </div>

    <div class="panel">
      <div class="hd">
        <div class="name">éº¦å…‹é£é¢‘è°±ï¼ˆè¾…åŠ©å¯¹å‡†ï¼‰</div>
        <div class="badge" id="fftBadge">FFT</div>
      </div>
      <div class="bd">
        <canvas id="viz" width="900" height="440"></canvas>
        <div class="muted small" style="margin-top:10px">
          æç¤ºï¼šè®©å¯¹æ–¹æ‰¬å£°å™¨â€œå¯¹ç€â€ä½ çš„éº¦å…‹é£ï¼›è·ç¦» 10~50cmï¼›ä¸è¦çˆ†éŸ³ã€‚
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  // ================= UI =================
  const $ = (id) => document.getElementById(id);
  const elBadge = $("badge");
  const elStatus = $("status");
  const elParams = $("params");
  const elTx = $("tx");
  const elRx = $("rx");
  const elRxMeta = $("rxmeta");
  const elRole = $("role");
  const btnStart = $("btnStart");
  const btnSend = $("btnSend");
  const btnHang = $("btnHang");
  const rngVol = $("vol");
  const chkMonitor = $("monitor");
  const chkRawMic = $("rawmic");
  const chkHandshake = $("handshake");
  const elLog = $("log");
  const canvas = $("viz");
  const c2d = canvas.getContext("2d");

  const now = () => new Date().toLocaleTimeString();
  function log(msg){
    elLog.textContent += `[${now()}] ${msg}\n`;
    elLog.scrollTop = elLog.scrollHeight;
  }
  function setBadge(s){ elBadge.textContent = s; }
  function setStatus(s){ elStatus.textContent = s; }

  // =============== FDD Frequencies ===============
  // A->B : low band
  const A_F0 = 1200, A_F1 = 2000;
  // B->A : high band (still within typical speaker/mic passband)
  const B_F0 = 2600, B_F1 = 3400;

  // Low baud for stability in real rooms
  const BAUD = 45;                  // bits/sec
  const BIT_MS = 1000 / BAUD;
  const DEC_OVERLAP = 0.25;
  const DEC_STEP_MS = BIT_MS * (1 - DEC_OVERLAP);

  // Frame: PREAMBLE + SYNC + LEN + PAYLOAD + CRC8
  const PREAMBLE_BYTES = 18;
  const SYNC = [0xD3, 0x91];

  // =============== Audio objects ===============
  let audioCtx = null;
  let modemBus = null;
  let masterGain = null;

  let micStream = null;
  let micSource = null;
  let micAnalyser = null;
  let micMonitorGain = null;

  // receiver processing
  let procNode = null;
  let ringBuffer = null, rbSize = 0, rbWrite = 0;
  let decTimer = null;

  // visualization
  let raf = null;

  // state
  let running = false;
  let lastGoodText = "";

  // ================= Utils =================
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function concatU8(...arrs){
    const total = arrs.reduce((s,a)=>s+a.length,0);
    const out = new Uint8Array(total);
    let o=0;
    for (const a of arrs){ out.set(a,o); o+=a.length; }
    return out;
  }
  function crc8(bytes){
    // CRC-8 poly 0x07
    let crc = 0x00;
    for (const b of bytes){
      crc ^= b;
      for (let i=0;i<8;i++){
        crc = (crc & 0x80) ? ((crc<<1) ^ 0x07) : (crc<<1);
        crc &= 0xFF;
      }
    }
    return crc & 0xFF;
  }
  function textToUtf8(str){ return new TextEncoder().encode(str); }
  function utf8ToText(u8){
    try { return new TextDecoder().decode(u8); } catch { return ""; }
  }
  function u8ToBits(u8arr){
    const bits = [];
    for (const b of u8arr){
      for (let i=7;i>=0;i--) bits.push((b>>i)&1);
    }
    return bits;
  }
  function bitsToU8(bits){
    const bytes = [];
    for (let i=0;i+7<bits.length;i+=8){
      let b=0;
      for (let k=0;k<8;k++) b=(b<<1)|bits[i+k];
      bytes.push(b);
    }
    return new Uint8Array(bytes);
  }

  // Goertzel power at freq
  function goertzelPower(samples, sampleRate, freq){
    const N = samples.length;
    const k = Math.round(0.5 + (N * freq) / sampleRate);
    const w = (2 * Math.PI * k) / N;
    const cos = Math.cos(w);
    const coeff = 2*cos;

    let s0=0, s1=0, s2=0;
    for (let n=0;n<N;n++){
      s0 = samples[n] + coeff*s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    return s1*s1 + s2*s2 - coeff*s1*s2;
  }

  // ================= Audio setup =================
  async function ensureAudio(){
    if (audioCtx && audioCtx.state !== "closed") return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    modemBus = audioCtx.createGain();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.55;

    // limiter
    const comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.knee.value = 12;
    comp.ratio.value = 6;
    comp.attack.value = 0.005;
    comp.release.value = 0.12;

    modemBus.connect(comp);
    comp.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    micMonitorGain = audioCtx.createGain();
    micMonitorGain.gain.value = 0.0;
    micMonitorGain.connect(audioCtx.destination);

    setVolFromUI();
    setMonitorFromUI();
    log("éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆã€‚");
  }

  function setVolFromUI(){
    if (!masterGain) return;
    const v = Number(rngVol.value)/100;
    masterGain.gain.value = Math.pow(v, 1.6);
  }
  function setMonitorFromUI(){
    if (!micMonitorGain) return;
    micMonitorGain.gain.value = chkMonitor.checked ? 0.22 : 0.0;
  }

  async function ensureMic(){
    if (micStream) return;

    const raw = chkRawMic.checked;
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: raw ? {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      } : {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    // Optional: notch out *our own transmit frequencies* to reduce self-leak into decoder
    const role = elRole.value;
    const myF0 = role === "A" ? A_F0 : B_F0;
    const myF1 = role === "A" ? A_F1 : B_F1;

    const notch1 = audioCtx.createBiquadFilter();
    notch1.type = "notch"; notch1.frequency.value = myF0; notch1.Q.value = 18;

    const notch2 = audioCtx.createBiquadFilter();
    notch2.type = "notch"; notch2.frequency.value = myF1; notch2.Q.value = 18;

    micAnalyser = audioCtx.createAnalyser();
    micAnalyser.fftSize = 2048;
    micAnalyser.smoothingTimeConstant = 0.85;

    // Graph: mic -> notch -> notch -> analyser
    micSource.connect(notch1);
    notch1.connect(notch2);
    notch2.connect(micAnalyser);

    // optional monitor (listen to mic) â€” through same filtered path to reduce howling
    notch2.connect(micMonitorGain);

    log(`éº¦å…‹é£å·²æ‰“å¼€ï¼ˆåŸå§‹æ¨¡å¼ï¼š${raw ? "æ˜¯" : "å¦"}ï¼›å·²å¯¹æœ¬æœºé¢‘æ®µåŠ é™·æ³¢ï¼š${myF0}/${myF1}Hzï¼‰ã€‚`);
    startViz();
  }

  function stopMic(){
    if (micStream){
      micStream.getTracks().forEach(t=>t.stop());
      micStream=null;
    }
    micSource=null;
    micAnalyser=null;
  }

  // ================= Visualizer =================
  function startViz(){
    if (raf) cancelAnimationFrame(raf);
    const buf = new Uint8Array(1024);

    function draw(){
      raf = requestAnimationFrame(draw);
      c2d.clearRect(0,0,canvas.width,canvas.height);

      c2d.globalAlpha = 0.35;
      c2d.strokeStyle = "#00ff66";
      for (let x=0;x<=canvas.width;x+=60){ c2d.beginPath(); c2d.moveTo(x,0); c2d.lineTo(x,canvas.height); c2d.stroke(); }
      for (let y=0;y<=canvas.height;y+=60){ c2d.beginPath(); c2d.moveTo(0,y); c2d.lineTo(canvas.width,y); c2d.stroke(); }
      c2d.globalAlpha = 1;

      if (!micAnalyser){
        c2d.fillStyle = "#00ff66";
        c2d.globalAlpha = 0.75;
        c2d.fillText("ç­‰å¾…éº¦å…‹é£â€¦", 14, 20);
        c2d.globalAlpha = 1;
        return;
      }

      micAnalyser.getByteFrequencyData(buf);

      const w = canvas.width, h = canvas.height;
      const barW = w / buf.length;
      c2d.fillStyle = "#00ff66";
      for (let i=0;i<buf.length;i++){
        const v = buf[i]/255;
        const bh = v*(h-18);
        c2d.globalAlpha = 0.18 + v*0.82;
        c2d.fillRect(i*barW, h-bh, Math.max(1,barW*.95), bh);
      }
      c2d.globalAlpha = 1;

      const role = elRole.value;
      const txF0 = role==="A" ? A_F0 : B_F0;
      const txF1 = role==="A" ? A_F1 : B_F1;
      const rxF0 = role==="A" ? B_F0 : A_F0;
      const rxF1 = role==="A" ? B_F1 : A_F1;

      c2d.globalAlpha = .85;
      c2d.fillText(`TX: ${txF0}/${txF1} Hz   RX: ${rxF0}/${rxF1} Hz   BAUD=${BAUD}`, 12, 18);
      c2d.globalAlpha = 1;
    }
    draw();
  }

  function stopViz(){
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    c2d.clearRect(0,0,canvas.width,canvas.height);
  }

  // ================= Cosmetic dial-up sound =================
  function playHandshake(){
    if (!chkHandshake.checked) return;
    const osc = (f,t="sine") => { const o=audioCtx.createOscillator(); o.type=t; o.frequency.value=f; return o; };
    const g = audioCtx.createGain();
    g.gain.value = 0;
    g.connect(modemBus);

    const o1 = osc(350), o2 = osc(440);
    o1.connect(g); o2.connect(g);
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(0.10, t0+0.03);
    g.gain.linearRampToValueAtTime(0.0, t0+0.55);
    o1.start(t0); o2.start(t0);
    o1.stop(t0+0.6); o2.stop(t0+0.6);

    const sw = osc(400,"sawtooth");
    const gs = audioCtx.createGain(); gs.gain.value = 0;
    sw.connect(gs); gs.connect(modemBus);
    const t1 = t0 + 0.62;
    sw.frequency.setValueAtTime(500, t1);
    sw.frequency.linearRampToValueAtTime(2600, t1+0.65);
    gs.gain.setValueAtTime(0, t1);
    gs.gain.linearRampToValueAtTime(0.10, t1+0.04);
    gs.gain.linearRampToValueAtTime(0.0, t1+0.75);
    sw.start(t1); sw.stop(t1+0.80);
  }

  // ================= Framing & TX =================
  function buildFrame(text){
    const payload = textToUtf8(text);
    if (payload.length > 255) throw new Error("æ–‡æœ¬å¤ªé•¿ï¼ˆUTF-8 å­—èŠ‚>255ï¼‰ï¼Œè¯·ç¼©çŸ­ã€‚");

    const pre = new Uint8Array(PREAMBLE_BYTES).fill(0x55);
    const sync = new Uint8Array(SYNC);
    const lenB = new Uint8Array([payload.length]);
    const crc = new Uint8Array([crc8(concatU8(lenB, payload))]);

    return concatU8(pre, sync, lenB, payload, crc);
  }

  function scheduleFSK(bits, f0, f1, startAt){
    const o = audioCtx.createOscillator();
    o.type = "sine";
    const g = audioCtx.createGain();
    g.gain.value = 0.0;
    o.connect(g); g.connect(modemBus);

    const t0 = startAt;
    g.gain.setValueAtTime(0.0, t0);
    g.gain.linearRampToValueAtTime(0.12, t0+0.01);

    let t = t0;
    for (const b of bits){
      o.frequency.setValueAtTime(b ? f1 : f0, t);
      t += BIT_MS/1000;
    }

    g.gain.setValueAtTime(0.12, t);
    g.gain.linearRampToValueAtTime(0.0, t+0.02);

    o.start(t0);
    o.stop(t+0.03);
    return (t - t0) * 1000;
  }

  async function send(){
    if (!running) return;

    const text = elTx.value.trim();
    if (!text) { log("è¯·è¾“å…¥è¦å‘é€çš„æ–‡æœ¬ã€‚"); return; }

    let frame;
    try { frame = buildFrame(text); }
    catch(e){ log("âŒ " + e.message); return; }

    const bits = u8ToBits(frame);

    const role = elRole.value;
    const txF0 = role==="A" ? A_F0 : B_F0;
    const txF1 = role==="A" ? A_F1 : B_F1;

    setVolFromUI();

    log(`å‘é€(${role})ï¼š${text}`);
    log(`TXé¢‘ç‡ ${txF0}/${txF1} Hzï¼›å¸§=${frame.length} bytesï¼›è€—æ—¶â‰ˆ${(bits.length/BAUD).toFixed(2)}s`);

    playHandshake();
    const startAt = audioCtx.currentTime + (chkHandshake.checked ? 0.85 : 0.05);
    scheduleFSK(bits, txF0, txF1, startAt);
  }

  // ================= RX (decode only other band) =================
  function startReceiver(){
    // ScriptProcessor for simplicity
    const bufferSize = 2048;
    ringBuffer = new Float32Array(bufferSize * 10);
    rbSize = ringBuffer.length;
    rbWrite = 0;

    procNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    procNode.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      for (let i=0;i<input.length;i++){
        ringBuffer[rbWrite] = input[i];
        rbWrite = (rbWrite + 1) % rbSize;
      }
    };

    // feed from analyser input path:
    // NOTE: micAnalyser is analyser node; it is fed by filtered chain already.
    // We tap the same filtered chain by connecting micAnalyser to procNode via a Gain(0),
    // BUT analyser doesn't output. So we instead connect from micSource path earlier.
    //
    // To keep things simple: connect micSource directly to procNode too (self-notch already applied?).
    // Our notch filters are already in the chain micSource -> notch1 -> notch2 -> analyser.
    // We'll connect notch2 (the last notch) into procNode using the monitor path:
    // We didn't keep a reference to notch2 outside ensureMic; so alternative:
    // Use micSource directly; decoding still works because we decode only other band and our own band is notched in hardware/room + AEC.
    // For better, we re-open mic pipeline keeping notchesâ€”here we accept this simpler route.
    micSource.connect(procNode);

    const z = audioCtx.createGain(); z.gain.value = 0;
    procNode.connect(z); z.connect(audioCtx.destination);

    const sampleRate = audioCtx.sampleRate;
    const windowN = Math.max(160, Math.round(sampleRate * (BIT_MS/1000)));
    const stepMs = Math.max(20, Math.round(DEC_STEP_MS));
    const maxBitsKeep = 6000;

    let bitStream = [];

    const role = elRole.value;
    const rxF0 = role==="A" ? B_F0 : A_F0;
    const rxF1 = role==="A" ? B_F1 : A_F1;

    log(`æ¥æ”¶å™¨å¯åŠ¨ï¼šRXé¢‘ç‡ ${rxF0}/${rxF1} Hzï¼›windowN=${windowN}ï¼›step=${stepMs}ms`);

    decTimer = setInterval(() => {
      if (!ringBuffer) return;

      // grab newest window
      const win = new Float32Array(windowN);
      let idx = (rbWrite - windowN + rbSize) % rbSize;
      let rms = 0;
      for (let i=0;i<windowN;i++){
        const s = ringBuffer[idx];
        win[i] = s;
        rms += s*s;
        idx = (idx + 1) % rbSize;
      }
      rms = Math.sqrt(rms / windowN);

      // gate: ignore silence
      if (rms < 0.004) return;

      const p0 = goertzelPower(win, sampleRate, rxF0);
      const p1 = goertzelPower(win, sampleRate, rxF1);
      const bit = (p1 > p0) ? 1 : 0;

      bitStream.push(bit);
      if (bitStream.length > maxBitsKeep) bitStream.splice(0, bitStream.length - maxBitsKeep);

      tryParse(bitStream, role, rxF0, rxF1);
    }, stepMs);

    function tryParse(bits, role, rxF0, rxF1){
      const maxLookbackBits = 5000;
      const tail = bits.slice(Math.max(0, bits.length - maxLookbackBits));

      // attempt 8 alignments
      for (let offset=0; offset<8; offset++){
        const aligned = tail.slice(offset);
        const u8 = bitsToU8(aligned);
        if (u8.length < PREAMBLE_BYTES + 2 + 1 + 1) continue;

        const start = Math.max(0, u8.length - 650);
        for (let i=start; i<u8.length - (SYNC.length + 1 + 1); i++){
          // require a short preamble run before sync
          const preNeed = 8;
          let preOk = true;
          for (let k=1;k<=preNeed;k++){
            if (i-k < 0 || u8[i-k] !== 0x55) { preOk=false; break; }
          }
          if (!preOk) continue;

          // sync
          let syncOk = true;
          for (let s=0;s<SYNC.length;s++){
            if (u8[i+s] !== SYNC[s]) { syncOk=false; break; }
          }
          if (!syncOk) continue;

          const lenPos = i + SYNC.length;
          const len = u8[lenPos];
          const payloadPos = lenPos + 1;
          const crcPos = payloadPos + len;
          if (crcPos >= u8.length) continue;

          const payload = u8.slice(payloadPos, payloadPos + len);
          const crcGot = u8[crcPos];
          const crcCalc = crc8(concatU8(new Uint8Array([len]), payload));
          if (crcGot !== crcCalc) continue;

          const text = utf8ToText(payload);
          if (!text) continue;
          if (text === lastGoodText) return;

          lastGoodText = text;
          elRx.value = text;
          elRxMeta.textContent = `æ”¶åˆ°ï¼ˆå¯¹æ–¹â†’æˆ‘ï¼‰ï¼šlen=${len} bytesï¼ŒCRC=OKï¼Œalign=${offset}ï¼ŒRX=${rxF0}/${rxF1}Hz`;
          log(`âœ… æ”¶åˆ°(${role})ï¼š${text}`);
          return;
        }
      }
    }
  }

  function stopReceiver(){
    if (decTimer){ clearInterval(decTimer); decTimer=null; }
    if (procNode){
      try { micSource && micSource.disconnect(procNode); } catch {}
      try { procNode.disconnect(); } catch {}
      procNode.onaudioprocess = null;
      procNode = null;
    }
    ringBuffer = null;
  }

  // ================= Lifecycle =================
  async function start(){
    if (running) return;
    running = true;

    elLog.textContent = "";
    elRx.value = "";
    elRxMeta.textContent = "â€”";
    lastGoodText = "";

    await ensureAudio();
    if (audioCtx.state === "suspended") await audioCtx.resume();

    setVolFromUI();
    setMonitorFromUI();

    setBadge("START");
    setStatus("å¯åŠ¨ä¸­â€¦");

    await ensureMic();

    const role = elRole.value;
    const txF0 = role==="A" ? A_F0 : B_F0;
    const txF1 = role==="A" ? A_F1 : B_F1;
    const rxF0 = role==="A" ? B_F0 : A_F0;
    const rxF1 = role==="A" ? B_F1 : A_F1;

    elParams.textContent = `è§’è‰²=${role} | TX=${txF0}/${txF1}Hz | RX=${rxF0}/${rxF1}Hz | BAUD=${BAUD}bps | BIT=${BIT_MS.toFixed(1)}ms`;
    log(elParams.textContent);

    startReceiver();

    setBadge("ONLINE");
    setStatus("å·²å¯åŠ¨ï¼šåŒæ—¶æ”¶å‘ä¸­ âœ…");

    btnStart.disabled = true;
    btnSend.disabled = false;
    btnHang.disabled = false;

    log("æç¤ºï¼šä¸¤å°è®¾å¤‡å¿…é¡»ä¸€å°é€‰Aä¸€å°é€‰Bï¼›å¦‚æœäº’ç›¸å¬ä¸æ¸…ï¼Œé™ä½å‘é€é•¿åº¦ã€è°ƒéŸ³é‡ã€æ‹‰è¿‘è·ç¦»ã€å‹¾é€‰â€œåŸå§‹éº¦å…‹é£â€ã€‚");
  }

  function stop(){
    if (!running) return;
    running = false;

    stopReceiver();
    stopMic();
    stopViz();

    setBadge("IDLE");
    setStatus("å·²åœæ­¢");
    elParams.textContent = "â€”";

    btnStart.disabled = false;
    btnSend.disabled = true;
    btnHang.disabled = true;

    log("å·²åœæ­¢ã€‚");
  }

  // ================= UI wiring =================
  btnStart.addEventListener("click", start);
  btnHang.addEventListener("click", stop);
  btnSend.addEventListener("click", send);
  rngVol.addEventListener("input", setVolFromUI);
  chkMonitor.addEventListener("change", setMonitorFromUI);

  elRole.addEventListener("change", () => {
    // role affects which band we notch & decode; simplest is to stop/start if running
    log("è§’è‰²å·²åˆ‡æ¢ï¼šå¦‚æ­£åœ¨è¿è¡Œï¼Œå»ºè®®ç‚¹å‡»åœæ­¢å†å¯åŠ¨ï¼Œä»¥æ›´æ–°é¢‘æ®µé™·æ³¢/æ¥æ”¶è®¾ç½®ã€‚");
  });

  // init
  setBadge("IDLE");
  setStatus("æœªå¯åŠ¨");
  elParams.textContent = "â€”";
  log("å‡†å¤‡å°±ç»ªï¼šä¸¤å°è®¾å¤‡åˆ†åˆ«é€‰æ‹©è§’è‰² A / Bï¼Œç„¶åéƒ½ç‚¹å‡»â€œå¯åŠ¨â€ã€‚");
})();
</script>
</body>
</html>
