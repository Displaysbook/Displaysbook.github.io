<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ç©ºæ°”å£°å­¦ä¼ æ•°æ®ï¼ˆ2-FSK + CRC32 + å¯é€‰é‡å¤çº é”™ï¼‰</title>
<style>
  :root{--bg:#000;--fg:#00ff66;--dim:rgba(0,255,102,.25);--panel:rgba(0,255,102,.08);--warn:#ffd000;--err:#ff3b3b;}
  html,body{height:100%;margin:0;background:radial-gradient(ellipse at top,#07110a 0%,#000 55%,#000 100%);color:var(--fg);
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
  .wrap{max-width:1050px;margin:0 auto;padding:16px;display:grid;gap:12px;}
  .title{border:1px solid var(--dim);border-radius:14px;padding:12px 14px;background:linear-gradient(180deg,rgba(0,255,102,.10),rgba(0,255,102,.04));
    box-shadow:0 0 18px rgba(0,255,102,.08);display:flex;justify-content:space-between;gap:12px;align-items:baseline;}
  .title h1{margin:0;font-size:16px;}
  .hint{opacity:.8;font-size:12px;line-height:1.25}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:12px;}
  @media (max-width:900px){.grid{grid-template-columns:1fr;}}
  .panel{border:1px solid var(--dim);border-radius:14px;background:var(--panel);box-shadow:0 0 18px rgba(0,255,102,.06);overflow:hidden;}
  .hd{padding:10px 12px;border-bottom:1px solid var(--dim);background:rgba(0,255,102,.06);display:flex;justify-content:space-between;align-items:center;}
  .name{font-weight:700;font-size:12px;opacity:.95;}
  .badge{font-size:11px;padding:3px 8px;border:1px solid var(--dim);border-radius:999px;background:rgba(0,0,0,.25);opacity:.9;}
  .bd{padding:12px;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  @media (max-width:520px){.row{grid-template-columns:1fr;}}
  .kv{border:1px solid var(--dim);border-radius:12px;padding:10px 12px;background:rgba(0,0,0,.25);}
  .k{font-size:11px;opacity:.75;}
  .v{font-size:13px;margin-top:4px;}
  button{appearance:none;border:1px solid var(--dim);background:rgba(0,255,102,.08);color:var(--fg);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700;letter-spacing:.3px;}
  button:hover{background:rgba(0,255,102,.12);}
  button:disabled{opacity:.5;cursor:not-allowed;}
  .btn-err{border-color:rgba(255,59,59,.35);color:var(--err);background:rgba(255,59,59,.08);}
  label{display:inline-flex;gap:8px;align-items:center;font-size:12px;opacity:.9;border:1px solid var(--dim);background:rgba(0,0,0,.25);padding:8px 10px;border-radius:12px;user-select:none;}
  input[type="checkbox"]{transform:translateY(1px);}
  input[type="range"]{width:170px;}
  textarea,input[type="text"]{
    width:100%;box-sizing:border-box;border:1px solid var(--dim);background:rgba(0,0,0,.35);
    color:var(--fg);border-radius:12px;padding:10px 12px;outline:none;font-family:inherit;
  }
  textarea{min-height:86px;resize:vertical;}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .log{height:260px;overflow:auto;border:1px solid var(--dim);background:rgba(0,0,0,.35);border-radius:12px;padding:10px;line-height:1.35;font-size:12px;white-space:pre-wrap;}
  canvas{width:100%;height:220px;border:1px solid var(--dim);border-radius:12px;background:rgba(0,0,0,.35);display:block;}
  .muted{opacity:.7;}
</style>
</head>
<body>
<div class="wrap">
  <div class="title">
    <h1>ğŸ”ŠğŸ™ï¸ ç©ºæ°”å£°å­¦ä¼ æ•°æ®ï¼ˆ2-FSK + CRC32 + å¯é€‰é‡å¤çº é”™ï¼‰</h1>
    <div class="hint">
      ä¸¤å°è®¾å¤‡æœ€ç¨³ï¼šä¸€å°å‘å£°ã€ä¸€å°æ”¶éŸ³ï¼›è·ç¦» 10â€“50cmï¼›ç¯å¢ƒå®‰é™ï¼›éŸ³é‡ä¸­ç­‰ã€‚<br/>
      è‹¥è¯†åˆ«å›°éš¾ï¼šæ‰“å¼€ã€Œé‡å¤çº é”™ x3ã€å¹¶æŠŠ bit æ—¶é•¿è°ƒå¤§ã€‚
    </div>
  </div>

  <div class="grid">
    <div class="panel">
      <div class="hd">
        <div class="name">æ§åˆ¶å°</div>
        <div class="badge" id="badge">IDLE</div>
      </div>
      <div class="bd">

        <div class="row">
          <div class="kv">
            <div class="k">çŠ¶æ€</div>
            <div class="v" id="status">æœªå¯åŠ¨</div>
          </div>
          <div class="kv">
            <div class="k">å‚æ•°</div>
            <div class="v" id="params">â€”</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">å‘é€æ–‡æœ¬</div>
          <div class="v">
            <textarea id="tx" placeholder="è¾“å…¥è¦é€šè¿‡ç©ºæ°”å‘é€çš„æ–‡æœ¬ï¼ˆå»ºè®®å…ˆç”¨çŸ­å¥æµ‹è¯•ï¼Œæ¯”å¦‚ 20~60 å­—ï¼‰"></textarea>
            <div style="height:8px"></div>
            <div class="controls">
              <button id="btnStart">å¼€å§‹ï¼ˆæ‰“å¼€éŸ³é¢‘+éº¦å…‹é£+æ¥æ”¶å™¨ï¼‰</button>
              <button id="btnSend" disabled>å‘é€</button>
              <button id="btnStop" class="btn-err" disabled>åœæ­¢</button>

              <label title="å‘å°„éŸ³é‡">
                éŸ³é‡ <input id="vol" type="range" min="0" max="100" value="55"/>
              </label>

              <label title="æ¯ bit çš„æŒç»­æ—¶é—´ï¼ˆæ›´é•¿=æ›´ç¨³ä½†æ›´æ…¢ï¼‰">
                bit(ms) <input id="bitms" type="range" min="12" max="60" value="25"/>
                <span id="bitmsText">25</span>
              </label>

              <label title="é‡å¤çº é”™ï¼šæ¯ä¸ª bit å‘ 3 æ¬¡ï¼Œæ¥æ”¶ç«¯å¤šæ•°è¡¨å†³ã€‚æ›´ç¨³ä½†æ›´æ…¢ã€‚">
                <input id="rep3" type="checkbox" checked/>
                é‡å¤çº é”™ x3
              </label>

              <label title="å…³é—­å›å£°æ¶ˆé™¤/å™ªå£°æŠ‘åˆ¶é€šå¸¸æ›´åˆ©äºçº¯éŸ³è°ƒåˆ¶ï¼ˆä½†ç¯å¢ƒå™ªå£°ä¼šæ›´æ˜æ˜¾ï¼‰">
                <input id="rawmic" type="checkbox" checked/>
                åŸå§‹éº¦å…‹é£
              </label>
            </div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">æ¥æ”¶ç»“æœ</div>
          <div class="v">
            <input id="rx" type="text" readonly placeholder="æ”¶åˆ°çš„æ–‡æœ¬ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ"/>
            <div class="muted" id="rxmeta" style="margin-top:6px">â€”</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="kv">
          <div class="k">æ—¥å¿—</div>
          <div class="v"><div class="log" id="log"></div></div>
        </div>

      </div>
    </div>

    <div class="panel">
      <div class="hd">
        <div class="name">éº¦å…‹é£é¢‘è°±ï¼ˆè¾…åŠ©å¯¹å‡†ï¼‰</div>
        <div class="badge">FSK</div>
      </div>
      <div class="bd">
        <canvas id="viz" width="900" height="440"></canvas>
        <div class="muted" style="margin-top:10px;font-size:12px;">
          æœ¬ demo çš„ FSK é¢‘ç‡ï¼šF0=1500Hzï¼ŒF1=2500Hzï¼ˆåœ¨è¯­éŸ³å¸¦å†…ï¼Œæ‰¬å£°å™¨/éº¦å…‹é£æ›´å®¹æ˜“é€šè¿‡ï¼‰ã€‚
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------------- UI ----------------
  const $ = id => document.getElementById(id);
  const elBadge = $("badge");
  const elStatus = $("status");
  const elParams = $("params");
  const elTx = $("tx");
  const elRx = $("rx");
  const elRxMeta = $("rxmeta");
  const btnStart = $("btnStart");
  const btnSend = $("btnSend");
  const btnStop = $("btnStop");
  const rngVol = $("vol");
  const rngBitMs = $("bitms");
  const bitmsText = $("bitmsText");
  const chkRep3 = $("rep3");
  const chkRawMic = $("rawmic");
  const elLog = $("log");
  const canvas = $("viz");
  const c2d = canvas.getContext("2d");

  const now = () => new Date().toLocaleTimeString();
  function log(msg){
    elLog.textContent += `[${now()}] ${msg}\n`;
    elLog.scrollTop = elLog.scrollHeight;
  }
  function setBadge(s){ elBadge.textContent = s; }
  function setStatus(s){ elStatus.textContent = s; }

  rngBitMs.addEventListener("input", () => bitmsText.textContent = rngBitMs.value);

  // ---------------- Modem parameters ----------------
  // Pick tones in a range that most phone/laptop speakers & mics handle well.
  const F0 = 1500;       // bit 0
  const F1 = 2500;       // bit 1

  // Frame:
  // PREAMBLE: 0x55 repeated -> 01010101 ...
  // SYNC: 0x2D, 0xD4 (a recognizable pattern)
  // LEN: 2 bytes (big-endian)
  // PAYLOAD: UTF-8 bytes
  // CRC32: 4 bytes (big-endian)
  const PREAMBLE_BYTES = 24;
  const SYNC = [0x2D, 0xD4];

  // ---------------- Audio state ----------------
  let audioCtx = null;
  let masterGain = null;
  let txBus = null;

  let micStream = null;
  let micSource = null;

  // bandpass filter for RX to reject out-of-band noise
  let bp1 = null, bp2 = null;

  // sampling ring buffer
  let procNode = null;
  let ring = null, ringSize = 0, ringW = 0;

  let decTimer = null;
  let raf = null;

  let running = false;

  // ---------------- Utilities ----------------
  function concatU8(...arrs){
    const total = arrs.reduce((s,a)=>s+a.length,0);
    const out = new Uint8Array(total);
    let o=0;
    for (const a of arrs){ out.set(a,o); o+=a.length; }
    return out;
  }
  function textToUtf8(str){ return new TextEncoder().encode(str); }
  function utf8ToText(u8){ try { return new TextDecoder().decode(u8); } catch { return ""; } }

  function u8ToBits(u8arr){
    const bits = [];
    for (const b of u8arr){
      for (let i=7;i>=0;i--) bits.push((b>>i)&1);
    }
    return bits;
  }
  function bitsToU8(bits){
    const bytes = [];
    for (let i=0;i+7<bits.length;i+=8){
      let b=0;
      for (let k=0;k<8;k++) b=(b<<1)|bits[i+k];
      bytes.push(b);
    }
    return new Uint8Array(bytes);
  }

  // CRC32 (IEEE 802.3)
  const CRC32_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let i=0;i<256;i++){
      let c = i;
      for (let k=0;k<8;k++){
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function crc32(u8){
    let c = 0xFFFFFFFF;
    for (let i=0;i<u8.length;i++){
      c = CRC32_TABLE[(c ^ u8[i]) & 0xFF] ^ (c >>> 8);
    }
    return (c ^ 0xFFFFFFFF) >>> 0;
  }

  function u32ToBeBytes(x){
    return new Uint8Array([(x>>>24)&255,(x>>>16)&255,(x>>>8)&255,x&255]);
  }
  function beBytesToU32(b0,b1,b2,b3){
    return ((b0<<24)>>>0) | (b1<<16) | (b2<<8) | b3;
  }

  function u16ToBeBytes(x){
    return new Uint8Array([(x>>>8)&255, x&255]);
  }

  // repetition-3 coding
  function rep3Encode(bits){
    const out = [];
    for (const b of bits){ out.push(b,b,b); }
    return out;
  }
  function rep3Decode(bits){
    // majority vote over each group of 3
    const out = [];
    for (let i=0;i+2<bits.length;i+=3){
      const s = bits[i] + bits[i+1] + bits[i+2];
      out.push(s >= 2 ? 1 : 0);
    }
    return out;
  }

  // Goertzel
  function goertzelPower(samples, sampleRate, freq){
    const N = samples.length;
    const k = Math.round(0.5 + (N * freq) / sampleRate);
    const w = (2 * Math.PI * k) / N;
    const cos = Math.cos(w);
    const coeff = 2*cos;

    let s0=0, s1=0, s2=0;
    for (let n=0;n<N;n++){
      s0 = samples[n] + coeff*s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    return s1*s1 + s2*s2 - coeff*s1*s2;
  }

  // ---------------- Audio setup ----------------
  async function ensureAudio(){
    if (audioCtx && audioCtx.state !== "closed") return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    txBus = audioCtx.createGain();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.55;

    // mild limiter
    const comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.knee.value = 12;
    comp.ratio.value = 6;
    comp.attack.value = 0.005;
    comp.release.value = 0.12;

    txBus.connect(comp);
    comp.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    setVolFromUI();
    log("éŸ³é¢‘ç³»ç»Ÿå·²åˆå§‹åŒ–ã€‚");
  }

  function setVolFromUI(){
    if (!masterGain) return;
    const v = Number(rngVol.value)/100;
    masterGain.gain.value = Math.pow(v, 1.6);
  }
  rngVol.addEventListener("input", setVolFromUI);

  async function ensureMic(){
    if (micStream) return;

    const raw = chkRawMic.checked;
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: raw ? { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
                 : { echoCancellation:true,  noiseSuppression:true,  autoGainControl:true  }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    // bandpass around our tones (roughly 1.1k~2.9k)
    bp1 = audioCtx.createBiquadFilter();
    bp1.type = "highpass"; bp1.frequency.value = 900; bp1.Q.value = 0.7;
    bp2 = audioCtx.createBiquadFilter();
    bp2.type = "lowpass";  bp2.frequency.value = 3000; bp2.Q.value = 0.7;

    // ring buffer capture
    const bufferSize = 2048;
    ringSize = bufferSize * 10;
    ring = new Float32Array(ringSize);
    ringW = 0;

    procNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    procNode.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      for (let i=0;i<input.length;i++){
        ring[ringW] = input[i];
        ringW = (ringW + 1) % ringSize;
      }
    };

    // mic -> filters -> processor (keep alive)
    micSource.connect(bp1);
    bp1.connect(bp2);
    bp2.connect(procNode);

    const z = audioCtx.createGain(); z.gain.value = 0;
    procNode.connect(z); z.connect(audioCtx.destination);

    log(`éº¦å…‹é£å·²å¼€å¯ï¼ˆåŸå§‹æ¨¡å¼ï¼š${raw ? "æ˜¯" : "å¦"}ï¼‰ã€‚`);
  }

  function stopAll(){
    if (decTimer){ clearInterval(decTimer); decTimer=null; }
    if (procNode){
      try { procNode.disconnect(); } catch {}
      procNode.onaudioprocess = null;
      procNode = null;
    }
    if (bp2){ try { bp2.disconnect(); } catch {} bp2=null; }
    if (bp1){ try { bp1.disconnect(); } catch {} bp1=null; }
    if (micSource){ try { micSource.disconnect(); } catch {} micSource=null; }
    if (micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }

    ring=null;

    stopViz();

    running = false;
    btnStart.disabled = false;
    btnSend.disabled = true;
    btnStop.disabled = true;
    setBadge("IDLE");
    setStatus("å·²åœæ­¢");
    elParams.textContent = "â€”";
    log("å·²åœæ­¢ã€‚");
  }

  // ---------------- TX: build frame and send FSK ----------------
  function buildFrame(text){
    const payload = textToUtf8(text);
    if (payload.length > 800) throw new Error("æ–‡æœ¬å¤ªé•¿ï¼ˆå»ºè®®å…ˆæ§åˆ¶åœ¨ 800 å­—èŠ‚ä»¥å†…ï¼‰ã€‚");

    const pre = new Uint8Array(PREAMBLE_BYTES).fill(0x55);
    const sync = new Uint8Array(SYNC);
    const len = u16ToBeBytes(payload.length);

    const header = concatU8(sync, len);
    const c = crc32(concatU8(header, payload));
    const crcB = u32ToBeBytes(c);

    // full frame: preamble + sync + len + payload + crc
    return concatU8(pre, header, payload, crcB);
  }

  function scheduleFSK(bits, startAt, bitMs){
    // single oscillator, switch frequency per bit
    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    const g = audioCtx.createGain();
    g.gain.value = 0.0;
    osc.connect(g);
    g.connect(txBus);

    const t0 = startAt;
    const bitS = bitMs / 1000;

    // smooth envelope to reduce clicks
    g.gain.setValueAtTime(0.0, t0);
    g.gain.linearRampToValueAtTime(0.14, t0 + 0.01);

    let t = t0;
    for (const b of bits){
      osc.frequency.setValueAtTime(b ? F1 : F0, t);
      t += bitS;
    }

    g.gain.setValueAtTime(0.14, t);
    g.gain.linearRampToValueAtTime(0.0, t + 0.02);

    osc.start(t0);
    osc.stop(t + 0.03);

    return (t - t0) * 1000;
  }

  async function sendText(){
    if (!running) return;

    const text = elTx.value.trim();
    if (!text){ log("è¯·è¾“å…¥è¦å‘é€çš„æ–‡æœ¬ã€‚"); return; }

    let frame;
    try { frame = buildFrame(text); }
    catch(e){ log("âŒ " + e.message); return; }

    const bitMs = Number(rngBitMs.value);
    const rep3 = chkRep3.checked;

    // bytes -> bits
    let bits = u8ToBits(frame);
    if (rep3) bits = rep3Encode(bits);

    // update params
    const bps = 1000 / bitMs / (rep3 ? 3 : 1);
    elParams.textContent = `F0=${F0}Hz F1=${F1}Hz | bit=${bitMs}ms | é€Ÿåº¦â‰ˆ${bps.toFixed(1)}bps | çº é”™=${rep3 ? "é‡å¤x3" : "æ— "}`;
    log(`å‘é€ï¼špayload=${textToUtf8(text).length}B, frame=${frame.length}B, bits=${bits.length}ï¼ˆ${rep3 ? "rep3" : "raw"}ï¼‰`);

    // small â€œleaderâ€ silence then preamble is inside frame
    const startAt = audioCtx.currentTime + 0.08;
    const durMs = scheduleFSK(bits, startAt, bitMs);
    log(`å·²æ’ç¨‹å‘å°„ï¼šçº¦ ${(durMs/1000).toFixed(2)}s`);
  }

  // ---------------- RX: decode stream -> find frames -> CRC32 check ----------------
  function startDecoder(){
    const sr = audioCtx.sampleRate;
    const rep3 = chkRep3.checked; // use same setting for RX (ä¸¤ç«¯è¦ä¸€è‡´)
    const bitMs = Number(rngBitMs.value);

    // window length roughly one bit (or one repetition bit)
    const winN = Math.max(160, Math.round(sr * (bitMs/1000)));
    const stepMs = Math.max(12, Math.round(bitMs * 0.75)); // overlap for stability

    let bitStream = [];
    let lastGood = "";

    log(`æ¥æ”¶å™¨å‚æ•°ï¼šsampleRate=${sr}, winN=${winN}, step=${stepMs}ms, rep3=${rep3}`);

    decTimer = setInterval(() => {
      if (!ring) return;

      // take newest window
      const win = new Float32Array(winN);
      let idx = (ringW - winN + ringSize) % ringSize;

      // RMS gate
      let rms=0;
      for (let i=0;i<winN;i++){
        const s = ring[idx];
        win[i]=s;
        rms += s*s;
        idx = (idx + 1) % ringSize;
      }
      rms = Math.sqrt(rms / winN);
      if (rms < 0.004) return;

      const p0 = goertzelPower(win, sr, F0);
      const p1 = goertzelPower(win, sr, F1);
      const bit = (p1 > p0) ? 1 : 0;

      bitStream.push(bit);
      if (bitStream.length > 20000) bitStream.splice(0, bitStream.length-20000);

      // Try parse from tail with all alignments
      tryParse(bitStream);

    }, stepMs);

    function tryParse(bits){
      // If rep3, try to collapse triplets after alignment
      // We must try offsets 0..(rep3?2:7) for robustness:
      const maxLookback = 16000;
      const tail = bits.slice(Math.max(0, bits.length - maxLookback));

      const maxOffset = rep3 ? 2 : 7;
      for (let off=0; off<=maxOffset; off++){
        let aligned = tail.slice(off);

        if (rep3){
          aligned = rep3Decode(aligned);
        }

        // now aligned is "real bit stream", convert to bytes by trying 8 alignments
        for (let boff=0; boff<8; boff++){
          const b2 = aligned.slice(boff);
          const u8 = bitsToU8(b2);
          if (u8.length < PREAMBLE_BYTES + 2 + 2 + 4) continue;

          // search for: ... 0x55 run then SYNC then LEN then payload then CRC32
          const start = Math.max(0, u8.length - 1400);
          for (let i=start; i<u8.length - (2+2+4); i++){
            // require some 0x55 before sync (preamble)
            let preOk = true;
            const need = 10;
            for (let k=1;k<=need;k++){
              if (i-k < 0 || u8[i-k] !== 0x55){ preOk=false; break; }
            }
            if (!preOk) continue;

            if (u8[i] !== SYNC[0] || u8[i+1] !== SYNC[1]) continue;

            const len = (u8[i+2] << 8) | u8[i+3];
            const payloadPos = i + 4;
            const crcPos = payloadPos + len;
            if (len < 0 || len > 2000) continue;
            if (crcPos + 3 >= u8.length) continue;

            const payload = u8.slice(payloadPos, payloadPos + len);
            const crcGot = beBytesToU32(u8[crcPos], u8[crcPos+1], u8[crcPos+2], u8[crcPos+3]);

            const header = new Uint8Array([SYNC[0], SYNC[1], u8[i+2], u8[i+3]]);
            const crcCalc = crc32(concatU8(header, payload));

            if (crcGot !== crcCalc) continue;

            const text = utf8ToText(payload);
            if (!text) continue;

            if (text === lastGood) return;
            lastGood = text;

            elRx.value = text;
            elRxMeta.textContent = `CRC32=OK | len=${len}B | align(rep=${off},bit=${boff})`;
            log(`âœ… æ¥æ”¶æˆåŠŸï¼š${text}`);
            return;
          }
        }
      }
    }
  }

  // ---------------- Visualizer ----------------
  function startViz(){
    if (raf) cancelAnimationFrame(raf);
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;

    // Tap after bp2 if available; else tap micSource
    if (bp2) bp2.connect(analyser);
    else if (micSource) micSource.connect(analyser);

    const buf = new Uint8Array(1024);
    function draw(){
      raf = requestAnimationFrame(draw);
      c2d.clearRect(0,0,canvas.width,canvas.height);

      c2d.globalAlpha = 0.35;
      c2d.strokeStyle = "#00ff66";
      for (let x=0;x<=canvas.width;x+=60){ c2d.beginPath(); c2d.moveTo(x,0); c2d.lineTo(x,canvas.height); c2d.stroke(); }
      for (let y=0;y<=canvas.height;y+=60){ c2d.beginPath(); c2d.moveTo(0,y); c2d.lineTo(canvas.width,y); c2d.stroke(); }
      c2d.globalAlpha = 1;

      analyser.getByteFrequencyData(buf);
      const w = canvas.width, h = canvas.height;
      const barW = w / buf.length;
      c2d.fillStyle = "#00ff66";
      for (let i=0;i<buf.length;i++){
        const v = buf[i]/255;
        const bh = v*(h-18);
        c2d.globalAlpha = 0.18 + v*0.82;
        c2d.fillRect(i*barW, h-bh, Math.max(1,barW*.95), bh);
      }
      c2d.globalAlpha = 1;
      c2d.fillText(`F0=${F0}Hz  F1=${F1}Hz`, 12, 18);
    }
    draw();
  }

  function stopViz(){
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    c2d.clearRect(0,0,canvas.width,canvas.height);
  }

  // ---------------- Lifecycle ----------------
  async function start(){
    if (running) return;

    elLog.textContent = "";
    elRx.value = "";
    elRxMeta.textContent = "â€”";

    await ensureAudio();
    if (audioCtx.state === "suspended") await audioCtx.resume();
    setVolFromUI();

    await ensureMic();

    running = true;
    setBadge("RUN");
    setStatus("è¿è¡Œä¸­ï¼šå¯æ¥æ”¶ / å¯å‘é€ âœ…");

    btnStart.disabled = true;
    btnSend.disabled = false;
    btnStop.disabled = false;

    const bitMs = Number(rngBitMs.value);
    const rep3 = chkRep3.checked;
    const bps = 1000 / bitMs / (rep3 ? 3 : 1);
    elParams.textContent = `F0=${F0}Hz F1=${F1}Hz | bit=${bitMs}ms | é€Ÿåº¦â‰ˆ${bps.toFixed(1)}bps | çº é”™=${rep3 ? "é‡å¤x3" : "æ— "} | CRC32`;
    log(elParams.textContent);

    startDecoder();
    startViz();

    log("æç¤ºï¼šä¸¤å°è®¾å¤‡æœ€ç¨³ï¼›å…ˆæŠŠè·ç¦»æ‹‰è¿‘ï¼ŒéŸ³é‡ä¸­ç­‰ï¼›è¯†åˆ«å·®å°±æŠŠ bit(ms) è°ƒå¤§æˆ–å¼€é‡å¤x3ã€‚");
  }

  btnStart.addEventListener("click", start);
  btnSend.addEventListener("click", sendText);
  btnStop.addEventListener("click", stopAll);

  // init
  setBadge("IDLE");
  setStatus("æœªå¯åŠ¨");
  elParams.textContent = "â€”";
  log("å‡†å¤‡å°±ç»ªï¼šä¸¤å°è®¾å¤‡æ‰“å¼€æœ¬é¡µé¢ï¼Œæ¥æ”¶ç«¯å…ˆç‚¹â€œå¼€å§‹â€ï¼Œå‘é€ç«¯ç‚¹â€œå¼€å§‹â€åå†ç‚¹â€œå‘é€â€ã€‚");
})();
</script>
</body>
</html>
