<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YOLO ONNX 网页推理（2类｜Aim＋自定义中心＋重复发送＋类别开关＋Zoom）</title>
  <!-- onnxruntime-web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
  <style>
    :root{--bg:#0b0c10;--fg:#e8e8e8;--muted:#9aa0a6;--accent:#67b3ff}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,Segoe UI,Roboto,Arial}
    header{padding:14px 16px;border-bottom:1px solid #1f2328;background:#0e1116;position:sticky;top:0;z-index:10}
    h1{margin:0;font-size:18px}
    main{display:grid;grid-template-columns:360px 1fr;gap:14px;padding:14px;min-height:calc(100vh - 56px)}
    .panel{background:#0e1116;border:1px solid #1f2328;border-radius:14px;padding:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
    button{padding:8px 12px;border-radius:10px;border:1px solid #2b3036;background:#121721;color:var(--fg);cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type="range"]{width:140px}
    label{color:var(--muted)}
    small{color:var(--muted)}
    #videoWrap{position:relative;max-height:78vh;overflow:hidden;} /* 为缩放裁剪可视区域 */
    video,canvas{border-radius:14px;display:block;max-width:100%;height:auto}
    #canvas{position:absolute;left:0;top:0}
    pre{white-space:pre-wrap;background:#0b0f14;border:1px solid #1f2328;border-radius:10px;padding:8px;max-height:220px;overflow:auto}
    code{color:#8ab4f8}
    .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2b3036;color:var(--muted)}
    .switch{display:inline-flex;align-items:center;gap:6px}
    /* Zoom 目标：缩放中心固定 50%/50% */
    .zoomTarget{
      transform-origin: 50% 50%;
      will-change: transform;
    }
  </style>
</head>
<body>
<header>
  <h1>YOLO ONNX by displaysbook</h1>
</header>
<main>
  <section class="panel" id="ctrl">
    <div class="row">
      <button id="btnLoad">加载模型</button>
      <span id="modelStatus" class="badge">未加载</span>
    </div>

    <div class="row">
      <button id="btnWebcam">开启摄像头</button>
      <button id="btnScreen">共享屏幕</button>
      <button id="btnStop" disabled>停止</button>
    </div>

    <div class="row">
      <label>置信度: <span id="confVal">0.25</span></label>
      <input id="conf" type="range" min="0" max="1" step="0.01" value="0.25">
    </div>
    <div class="row">
      <label>IoU: <span id="iouVal">0.45</span></label>
      <input id="iou" type="range" min="0" max="1" step="0.01" value="0.45">
    </div>
    <div class="row">
      <label>最大框数:</label>
      <input id="maxDet" type="number" value="100" min="1" style="width:88px">
    </div>
    <div class="row" style="align-items:flex-end">
      <div style="flex:1 1 100%">
        <label>类别名（逗号分隔，2类）</label>
        <input id="classNames" value="class0,class1" style="width:100%">
      </div>
      <!-- 类别开关 -->
      <div class="row" style="margin-top:6px">
        <label class="switch" title="启用/禁用 class0">
          <input id="cls0" type="checkbox" checked>
          <span id="lblCls0">class0</span>
        </label>
        <label class="switch" title="启用/禁用 class1">
          <input id="cls1" type="checkbox" checked>
          <span id="lblCls1">class1</span>
        </label>
      </div>
    </div>

    <hr style="border-color:#1f2328">
    <div class="row">
      <span class="switch">
        <button id="btnAim">Aim 关</button>
        <span id="aimBadge" class="badge" title="每次请求发出的 dx,dy">未瞄准</span>
      </span>
    </div>
    <div class="row">
      <label>灵敏度: <span id="sensVal">0.25</span></label>
      <input id="sens" type="range" min="0.05" max="1" step="0.05" value="0.25">
    </div>
    <div class="row">
      <label>死区(px):</label>
      <input id="deadzone" type="number" value="8" min="0" max="100" style="width:72px">
      <label>最大步长(px):</label>
      <input id="maxStep" type="number" value="5" min="1" max="200" style="width:72px">
    </div>
    <div class="row">
      <label>发送间隔(ms):</label>
      <input id="rate" type="number" value="0" min="16" max="1000" style="width:88px">
      <label class="switch"><input id="flipX" type="checkbox">反转X</label>
      <label class="switch"><input id="flipY" type="checkbox">反转Y</label>
    </div>
    <div class="row">
      <label>重复次数:</label>
      <input id="repeat" type="number" value="1" min="1" max="10" style="width:72px">
    </div>

    <!-- 自定义中心（百分比 + 画面点选） -->
    <div class="row">
      <label>中心 X(%):</label>
      <input id="centerX" type="number" value="50" min="0" max="100" step="0.1" style="width:72px">
      <label>中心 Y(%):</label>
      <input id="centerY" type="number" value="50" min="0" max="100" step="0.1" style="width:72px">
      <button id="pickCenter" title="点击后到右侧画面点击取点">画面点选</button>
    </div>

    <!-- 画面缩放（中心固定 50%/50%） -->
    <div class="row">
      <label>缩放(zoom): <span id="zoomVal">1.0×</span></label>
      <input id="zoom" type="range" min="0.5" max="4" step="0.1" value="1">
    </div>

    <div class="row"><small>模型地址: <code>https://Displaysbook.github.io/best.onnx</code></small></div>

    <details>
      <summary>调试日志</summary>
      <pre id="log"></pre>
    </details>
  </section>

  <section class="panel">
    <div id="videoWrap">
      <video id="video" class="zoomTarget" playsinline muted></video>
      <canvas id="canvas" class="zoomTarget" width="1280" height="720"></canvas>
    </div>
  </section>
</main>

<script>
  // ================== 配置 ==================
  const MODEL_URL = 'https://Displaysbook.github.io/best.onnx';
  const TARGET_SIZE = 320; // 推理输入尺寸
  const AIM_URL = 'http://192.168.2.53/set'; // 你的设备接口
  // 注意：若本页是 https，直连 http 会被拦截（混合内容），建议 http 打开本页或设备支持 https。

  // ORT Web 环境（避免 numThreads 警告：非隔离环境退回单线程）
  ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/';
  ort.env.wasm.simd = true;
  if (self.crossOriginIsolated) {
    ort.env.wasm.numThreads = Math.min(4, navigator.hardwareConcurrency || 4);
  } else {
    ort.env.wasm.numThreads = 1;
    ort.env.wasm.proxy = false;
  }

  // ================== UI refs ==================
  const els = {
    btnLoad: document.getElementById('btnLoad'),
    btnWebcam: document.getElementById('btnWebcam'),
    btnScreen: document.getElementById('btnScreen'),
    btnStop: document.getElementById('btnStop'),
    modelStatus: document.getElementById('modelStatus'),
    conf: document.getElementById('conf'),
    confVal: document.getElementById('confVal'),
    iou: document.getElementById('iou'),
    iouVal: document.getElementById('iouVal'),
    maxDet: document.getElementById('maxDet'),
    classNames: document.getElementById('classNames'),
    log: document.getElementById('log'),
    video: document.getElementById('video'),
    canvas: document.getElementById('canvas'),
    wrap: document.getElementById('videoWrap'),
    // Aim
    btnAim: document.getElementById('btnAim'),
    aimBadge: document.getElementById('aimBadge'),
    sens: document.getElementById('sens'),
    sensVal: document.getElementById('sensVal'),
    deadzone: document.getElementById('deadzone'),
    maxStep: document.getElementById('maxStep'),
    rate: document.getElementById('rate'),
    flipX: document.getElementById('flipX'),
    flipY: document.getElementById('flipY'),
    repeat: document.getElementById('repeat'),
    // 类别开关
    cls0: document.getElementById('cls0'),
    cls1: document.getElementById('cls1'),
    lblCls0: document.getElementById('lblCls0'),
    lblCls1: document.getElementById('lblCls1'),
    // 自定义中心
    centerX: document.getElementById('centerX'),
    centerY: document.getElementById('centerY'),
    pickCenter: document.getElementById('pickCenter'),
    // Zoom
    zoom: document.getElementById('zoom'),
    zoomVal: document.getElementById('zoomVal'),
  };

  // ================== 状态 ==================
  const state = {
    session: null,
    running: false,
    stream: null,
    lastOutputInfo: null,
    // Aim 状态
    aim: {
      enabled: false,
      sensitivity: parseFloat(els.sens.value), // 像素→步进缩放
      deadzone: parseInt(els.deadzone.value, 10),
      maxStep: parseInt(els.maxStep.value, 10),
      rateMs: parseInt(els.rate.value, 10),
      flipX: false,
      flipY: false,
      lastSent: 0,
      repeat: parseInt((els.repeat?.value ?? '1'), 10) || 1,
    },
    // 自定义中心（百分比，0-100）
    center: { xPct: 50, yPct: 50 },
    pickingCenter: false,
    // Zoom
    zoom: 1.0, // 缩放倍数（中心固定 50%/50%）
  };

  function log(){
    const s = Array.from(arguments).map(a=> (typeof a==='object'? JSON.stringify(a): String(a))).join(' ');
    console.log('[log]',...arguments);
    els.log.textContent = (s + '\n' + els.log.textContent).slice(0, 8000);
  }

  // =============== 类别开关逻辑（class0/class1） ===============
  function updateClassLabels(){
    const names = els.classNames.value.split(',').map(s=>s.trim());
    els.lblCls0.textContent = names[0] || 'class0';
    els.lblCls1.textContent = names[1] || 'class1';
  }
  function enabledClassSet(){
    const s = new Set();
    if (els.cls0.checked) s.add(0);
    if (els.cls1.checked) s.add(1);
    return s;
  }
  updateClassLabels();
  els.classNames.addEventListener('input', updateClassLabels);

  // ================== 事件：Aim/UI ==================
  els.btnAim.onclick = () => {
    state.aim.enabled = !state.aim.enabled;
    els.btnAim.textContent = state.aim.enabled ? 'Aim 开' : 'Aim 关';
    els.aimBadge.textContent = state.aim.enabled ? '瞄准中…' : '未瞄准';
  };
  els.sens.oninput = () => {
    els.sensVal.textContent = els.sens.value;
    state.aim.sensitivity = parseFloat(els.sens.value);
  };
  els.deadzone.oninput = () => state.aim.deadzone = parseInt(els.deadzone.value,10);
  els.maxStep.oninput = () => state.aim.maxStep = parseInt(els.maxStep.value,10);
  els.rate.oninput = () => state.aim.rateMs = parseInt(els.rate.value,10);
  els.flipX.onchange = () => state.aim.flipX = els.flipX.checked;
  els.flipY.onchange = () => state.aim.flipY = els.flipY.checked;
  els.repeat.oninput = () => {
    let v = parseInt(els.repeat.value, 10);
    if (!Number.isFinite(v)) v = 1;
    state.aim.repeat = Math.max(1, Math.min(10, v));
  };

  // ================== 自定义中心：输入/点选 ==================
  els.centerX.oninput = () => {
    let v = parseFloat(els.centerX.value);
    if (Number.isFinite(v)) state.center.xPct = Math.max(0, Math.min(100, v));
  };
  els.centerY.oninput = () => {
    let v = parseFloat(els.centerY.value);
    if (Number.isFinite(v)) state.center.yPct = Math.max(0, Math.min(100, v));
  };
  els.pickCenter.onclick = () => {
    state.pickingCenter = true;
    els.pickCenter.textContent = '点击画面设置…';
    els.pickCenter.disabled = true;
    log('提示：在右侧画面点击一次以设置自定义中心');
  };
  els.canvas.addEventListener('click', (ev) => {
    if (!state.pickingCenter) return;
    const rect = els.canvas.getBoundingClientRect();
    // CSS 坐标 → 画布像素坐标（画布像素大小 = 视频像素大小）
    const scaleX = els.canvas.width / rect.width;
    const scaleY = els.canvas.height / rect.height;
    const cx = (ev.clientX - rect.left) * scaleX;
    const cy = (ev.clientY - rect.top) * scaleY;

    state.center.xPct = Math.max(0, Math.min(100, (cx / els.canvas.width) * 100));
    state.center.yPct = Math.max(0, Math.min(100, (cy / els.canvas.height) * 100));

    els.centerX.value = state.center.xPct.toFixed(1);
    els.centerY.value = state.center.yPct.toFixed(1);

    state.pickingCenter = false;
    els.pickCenter.textContent = '画面点选';
    els.pickCenter.disabled = false;
    log('中心位置已更新（百分比）', { xPct: state.center.xPct, yPct: state.center.yPct });
  });

  // ================== Zoom：中心固定 50%/50% ==================
  function applyZoom() {
    const z = state.zoom;
    // 同步缩放到 video 和 canvas（两者缩放一致，覆盖层始终对齐）
    [els.video, els.canvas].forEach(el => {
      el.style.transform = `scale(${z})`;
    });
    // 放大时裁剪可视区域
    els.wrap.style.overflow = z > 1 ? 'hidden' : 'visible';
  }
  els.zoom?.addEventListener('input', () => {
    state.zoom = parseFloat(els.zoom.value) || 1;
    els.zoomVal.textContent = `${state.zoom.toFixed(1)}×`;
    applyZoom();
  });
  // 初始化一次
  applyZoom();

  // ================== 加载模型 ==================
  els.btnLoad.onclick = async () => {
    try {
      els.btnLoad.disabled = true;
      els.modelStatus.textContent = '加载中…';

      const so = { executionProviders: ['wasm'] };
      const session = await ort.InferenceSession.create(MODEL_URL, so);
      state.session = session;

      const inputName = (session.inputNames && session.inputNames[0]) || 'images';
      const meta = session.inputMetadata ? session.inputMetadata[inputName] : undefined;
      const dims = meta && meta.dimensions ? meta.dimensions : [1,3,TARGET_SIZE,TARGET_SIZE];

      log('模型加载成功', { inputName, dims });
      els.modelStatus.textContent = '已加载 ✅';

      // 预热
      const warm = new ort.Tensor('float32', new Float32Array(1*3*TARGET_SIZE*TARGET_SIZE), [1,3,TARGET_SIZE,TARGET_SIZE]);
      await session.run({ [inputName]: warm });
      log('预热完成');
    } catch (e) {
      console.error(e);
      log('加载失败', e && (e.stack || String(e)));
      els.modelStatus.textContent = '加载失败 ❌';
    } finally {
      els.btnLoad.disabled = false;
    }
  };

  // ================== 采集视频 ==================
  els.btnWebcam.onclick = () => startStream({ video: { width: {ideal:1280}, height:{ideal:720} }, audio:false });
  els.btnScreen.onclick = async () => {
    try{
      const stream = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false });
      attachStream(stream);
    }catch(e){ log('屏幕共享失败', e.toString()); }
  };
  els.btnStop.onclick = () => stopStream();

  async function startStream(constraints){
    try{
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      attachStream(stream);
    }catch(e){ log('摄像头失败', e.toString()); }
  }
  function attachStream(stream){
    stopStream();
    state.stream = stream;
    els.video.srcObject = stream;
    els.video.onloadedmetadata = () => {
      els.video.play();
      resizeCanvas();
      applyZoom(); // 确保缩放在尺寸变化后仍生效
      startLoop();
    };
    els.btnStop.disabled = false;
  }
  function stopStream(){
    if(state.stream){
      state.stream.getTracks().forEach(t=>t.stop());
      state.stream = null;
    }
    state.running = false;
    els.btnStop.disabled = true;
  }
  function resizeCanvas(){
    const vw = els.video.videoWidth || 1280;
    const vh = els.video.videoHeight || 720;
    els.canvas.width = vw;
    els.canvas.height = vh;
    // 让覆盖画布在视觉上与视频等大
    els.canvas.style.width = els.video.clientWidth + 'px';
    els.canvas.style.height = els.video.clientHeight + 'px';
  }
  window.addEventListener('resize', () => { resizeCanvas(); applyZoom(); });
  els.conf.oninput = () => els.confVal.textContent = els.conf.value;
  els.iou.oninput = () => els.iouVal.textContent = els.iou.value;

  // ================== 推理主循环 ==================
  async function startLoop(){
    if(!state.session){ log('请先加载模型'); return; }
    if(state.running) return;
    state.running = true;

    const ctx = els.canvas.getContext('2d');
    const off = document.createElement('canvas');
    // willReadFrequently=true，避免 Canvas2D 警告
    const offCtx = off.getContext('2d', { willReadFrequently: true });

    async function frame(){
      if(!state.running) return;
      const vw = els.video.videoWidth, vh = els.video.videoHeight;
      if(!vw || !vh){ requestAnimationFrame(frame); return; }

      // 预处理：letterbox 到 TARGET_SIZE，通道 NCHW，归一化
      off.width = TARGET_SIZE; off.height = TARGET_SIZE;
      const metaLB = letterbox(offCtx, els.video, TARGET_SIZE, TARGET_SIZE);
      const input = toCHW(offCtx, TARGET_SIZE, TARGET_SIZE);

      // 推理
      const inputName = state.session.inputNames ? state.session.inputNames[0] : 'images';
      const feeds = { [inputName]: new ort.Tensor('float32', input, [1,3,TARGET_SIZE,TARGET_SIZE]) };
      let results;
      try{
        results = await state.session.run(feeds);
      }catch(e){ log('推理失败', e.toString()); state.running=false; return; }

      // 输出
      const outName = state.session.outputNames ? state.session.outputNames[0] : Object.keys(results)[0];
      const out = results[outName];
      state.lastOutputInfo = {name: outName, dims: out.dims, length: out.data.length};

      // 解码
      const confTh = parseFloat(els.conf.value);
      const iouTh = parseFloat(els.iou.value);
      const maxDet = Math.max(1, parseInt(els.maxDet.value||'100',10));
      const classes = els.classNames.value.split(',').map(s=>s.trim()).filter(Boolean);
      const enabled = enabledClassSet();

      let dets = decodeDetections(out, confTh, classes.length || 2);
      // 按类别开关进行过滤
      dets = dets.filter(d => enabled.has(d.cls));

      const kept = nms(dets, iouTh, maxDet); // 保留你的旧实现

      // 绘制
      ctx.clearRect(0,0,els.canvas.width, els.canvas.height);
      drawBoxes(ctx, kept, {scale: metaLB.scale, padX: metaLB.padX, padY: metaLB.padY, srcW:vw, srcH:vh});

      // Aim：只会跟踪被启用类别的目标
      aimTarget(kept, {scale: metaLB.scale, padX: metaLB.padX, padY: metaLB.padY, srcW:vw, srcH:vh}, performance.now());

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  }

  // ================== Aim 逻辑 ==================
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function aimTarget(dets, meta, tNow){
    if(!state.aim.enabled) return;
    if(!dets.length) { els.aimBadge.textContent = '未瞄准'; return; }
    if(tNow - state.aim.lastSent < state.aim.rateMs) return; // 发送限频

    // 取置信度最高的目标（dets 已按分数排序）
    const d = dets[0];

    // 还原到视频坐标系
    let x1 = (d.x1 - meta.padX) / meta.scale;
    let y1 = (d.y1 - meta.padY) / meta.scale;
    let x2 = (d.x2 - meta.padX) / meta.scale;
    let y2 = (d.y2 - meta.padY) / meta.scale;

    const cx = (x1 + x2) / 2;
    const cy = (y1 + y2) / 2;
    const centerX = (state.center.xPct / 100) * meta.srcW;
    const centerY = (state.center.yPct / 100) * meta.srcH;

    // 目标相对自定义中心的像素偏移（右/下为正）
    let dx = cx - centerX;
    let dy = cy - centerY;

    // 死区：接近中心不动，避免抖动
    if (Math.abs(dx) < state.aim.deadzone) dx = 0;
    if (Math.abs(dy) < state.aim.deadzone) dy = 0;

    // 像素偏移 → 步进（带灵敏度、最大步长）
    dx = clamp(Math.round(dx * state.aim.sensitivity), -state.aim.maxStep, state.aim.maxStep);
    dy = clamp(Math.round(dy * state.aim.sensitivity), -state.aim.maxStep, state.aim.maxStep);

    // 轴向反转（兼容设备坐标系）
    if (state.aim.flipX) dx = -dx;
    if (state.aim.flipY) dy = -dy;

    // 没有需要移动则不发请求
    if (dx === 0 && dy === 0) { els.aimBadge.textContent = '居中'; return; }

    // 发送 HTTP 控制（不读响应，规避 CORS），重复发送 N 次
    const url = `${AIM_URL}?x=${dx}&y=${dy}`;
    const n = Math.max(1, Math.min(10, state.aim.repeat | 0)); // 限制 1~10
    try {
      // 先记时间戳，避免重复期间被下一帧打断
      state.aim.lastSent = tNow;

      for (let i = 0; i < n; i++) {
        fetch(url, { mode: 'no-cors' });
        // 如需微间隔：可在此加入极短延时（会阻塞UI，默认关闭）
        // if (i < n - 1) busyWait(0.001); // 约 1ms
      }

      els.aimBadge.textContent = `dx=${dx}, dy=${dy} ×${n}`;
    } catch (e) {
      log('aim error', e.toString());
      els.aimBadge.textContent = 'Aim 发送失败';
    }
  }

  // 简单忙等微间隔（避免把 aimTarget 变成 async；可不用）
  function busyWait(seconds){
    const start = performance.now();
    const ms = seconds * 1000;
    while (performance.now() - start < ms) {}
  }

  // ================== 工具函数 ==================
  // letterbox 缩放+填充到 dstW×dstH（返回比例与边距）
  function letterbox(ctx, src, dstW, dstH){
    const sw = src.videoWidth || src.width, sh = src.videoHeight || src.height;
    const r = Math.min(dstW/sw, dstH/sh);
    const newW = Math.round(sw * r), newH = Math.round(sh * r);
    const padX = Math.floor((dstW - newW)/2), padY = Math.floor((dstH - newH)/2);
    ctx.fillStyle = 'rgb(114,114,114)';
    ctx.fillRect(0,0,dstW,dstH);
    ctx.drawImage(src, 0,0, sw,sh, padX,padY, newW,newH);
    return {scale:r, padX, padY, newW, newH};
  }

  // 将 offscreen RGBA 转 Float32 NCHW
  function toCHW(ctx, w, h){
    const {data} = ctx.getImageData(0,0,w,h); // RGBA
    const chw = new Float32Array(3*w*h);
    let p = 0, rOff = 0, gOff = w*h, bOff = 2*w*h;
    for(let i=0;i<data.length;i+=4){
      chw[rOff + p] = data[i]   /255; // R
      chw[gOff + p] = data[i+1] /255; // G
      chw[bOff + p] = data[i+2] /255; // B
      p++;
    }
    return chw;
  }

  // 解码常见 YOLO ONNX 输出 → [{x1,y1,x2,y2,score,cls}]
  function decodeDetections(out, confTh, numClassesGuess){
    const dims = out.dims; // 可能 [1,N,C] / [1,C,N] / [N,C]
    const data = out.data;
    let N=0, C=0, strideN=0, strideC=0;

    if(dims.length === 3){
      if(dims[1] > dims[2]){ // [1,N,C]
        N = dims[1]; C = dims[2]; strideN = C; strideC = 1;
      }else{ // [1,C,N]
        N = dims[2]; C = dims[1]; strideN = 1; strideC = N;
      }
    }else if(dims.length === 2){ // [N,C]
      N = dims[0]; C = dims[1]; strideN = C; strideC = 1;
    }else{
      log('未知输出维度', JSON.stringify(dims));
      return [];
    }

    const dets = [];
    for(let i=0;i<N;i++){
      const off = i*strideN;
      const x = data[off + 0*strideC];
      const y = data[off + 1*strideC];
      const w = data[off + 2*strideC];
      const h = data[off + 3*strideC];

      let score=0, cls=-1;
      if(C === 4 + numClassesGuess){
        let best=-1, bestIdx=-1;
        for(let j=4;j<C;j++){
          const v = data[off + j*strideC];
          if(v > best){ best=v; bestIdx=j-4; }
        }
        score = best; cls = bestIdx;
      } else if(C > 5){
        const obj = data[off + 4*strideC];
        let best=-1, bestIdx=-1;
        for(let j=5;j<C;j++){
          const v = data[off + j*strideC];
          if(v > best){ best=v; bestIdx=j-5; }
        }
        score = obj * best; cls = bestIdx;
      } else {
        continue;
      }

      if(score < confTh) continue;
      const x1 = x - w/2, y1 = y - h/2, x2 = x + w/2, y2 = y + h/2;
      dets.push({x1,y1,x2,y2,score,cls});
    }
    return dets.sort((a,b)=> b.score - a.score);
  }

  // NMS（按你的旧实现保留，可能存在索引漂移）
  function nms(dets, iouTh=0.45, maxDet=100){
    dets = dets.slice().sort((a,b)=>b.score - a.score);
    const keep = [];
    const areas = dets.map(d=> Math.max(0,d.x2-d.x1) * Math.max(0,d.y2-d.y1));

    while(dets.length && keep.length < maxDet){
      const cur = dets.shift();
      keep.push(cur);
      for(let i=dets.length-1;i>=0;i--){
        const d = dets[i];
        const xx1 = Math.max(cur.x1, d.x1);
        const yy1 = Math.max(cur.y1, d.y1);
        const xx2 = Math.min(cur.x2, d.x2);
        const yy2 = Math.min(cur.y2, d.y2);
        const w = Math.max(0, xx2-xx1);
        const h = Math.max(0, yy2-yy1);
        const inter = w*h;
        // 注意：沿用你原来的写法（可能出现索引漂移）
        const o = inter / (areas[dets.indexOf(d)] + (cur.x2-cur.x1)*(cur.y2-cur.y1) - inter + 1e-9);
        if(o > iouTh) dets.splice(i,1);
      }
    }
    return keep;
  }

  // 绘制框 + 自定义中心十字
  function drawBoxes(ctx, dets, meta){
    const {scale, padX, padY, srcW, srcH} = meta;
    ctx.lineWidth = Math.max(2, Math.min(srcW,srcH)/400);
    ctx.font = `${Math.max(10, Math.min(srcW,srcH)/35)}px ui-sans-serif`;

    // 自定义中心十字
    const cX = (state.center.xPct / 100) * srcW;
    const cY = (state.center.yPct / 100) * srcH;
    ctx.strokeStyle = 'rgba(255,255,255,.25)';
    ctx.beginPath();
    ctx.moveTo(cX, 0);  ctx.lineTo(cX, srcH);
    ctx.moveTo(0,  cY); ctx.lineTo(srcW, cY);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(cX, cY, Math.max(2, Math.min(srcW,srcH)/120), 0, Math.PI*2);
    ctx.stroke();

    const names = els.classNames.value.split(',').map(s=>s.trim()).filter(Boolean);

    for(const d of dets){
      let x1 = (d.x1 - padX) / scale;
      let y1 = (d.y1 - padY) / scale;
      let x2 = (d.x2 - padX) / scale;
      let y2 = (d.y2 - padY) / scale;

      x1 = Math.max(0, Math.min(srcW, x1));
      y1 = Math.max(0, Math.min(srcH, y1));
      x2 = Math.max(0, Math.min(srcW, x2));
      y2 = Math.max(0, Math.min(srcH, y2));

      const w = x2-x1, h = y2-y1;
      if(w<=2 || h<=2) continue;

      ctx.strokeStyle = '#67b3ff';
      ctx.fillStyle = 'rgba(103,179,255,0.18)';
      ctx.beginPath();
      ctx.rect(x1,y1,w,h);
      ctx.stroke();
      ctx.fill();

      const label = `${names[d.cls] ?? ('cls'+d.cls)} ${(d.score*100).toFixed(1)}%`;
      const tw = ctx.measureText(label).width + 8;
      const th = parseInt(ctx.font,10) + 6;
      ctx.fillStyle = 'rgba(14,17,22,0.85)';
      ctx.fillRect(x1, Math.max(0,y1-th), tw, th);
      ctx.strokeStyle = '#2b3036';
      ctx.strokeRect(x1, Math.max(0,y1-th), tw, th);
      ctx.fillStyle = '#e8e8e8';
      ctx.fillText(label, x1+4, Math.max(12, y1-4));
    }
  }

  // 显示最后一次输出维度（排错）
  setInterval(()=>{
    if(state.lastOutputInfo){
      els.modelStatus.title = `输出 ${state.lastOutputInfo.name} dims=${JSON.stringify(state.lastOutputInfo.dims)} len=${state.lastOutputInfo.length}`;
    }
  }, 500);
</script>
</body>
</html>
